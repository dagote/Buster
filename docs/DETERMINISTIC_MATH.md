# Deterministic Outcome Mathematics

The Buster protocol separates **core randomness commitment** from any
particular game logic.  This ensures the on‑chain component remains
minimal and the same seed can power arbitrarily complex games without
requiring contract changes.

## Core seed

- A cryptographically secure seed is generated by the server or one of
  the players before the game starts.
- A commitment (e.g. ``keccak256(seed)``) is published on‑chain via the
  `SeedCommit` contract (Phase 3) or in any other public log.
- The seed itself remains private until after the game; revealing it
  allows anyone to verify that the original commitment matched.

## Public randomness

To prevent the server from precomputing outcomes, the seed is typically
combined with a source of **public randomness** that cannot be influenced
by any single party.  Common sources include:

- Drand beacon values (Phase 4 reference)
- Chainlink VRF
- Block hashes or timestamps (with caution)

## Outcome function

All games derive their results from the same simple deterministic
formula:

```
outcome = H(seed || public_randomness || game_parameters)
```

where `H` is a secure hash (SHA‑256, keccak256, etc.) and
`game_parameters` encodes any additional inputs needed for the game
(e.g. dice sides, player actions, sequence numbers).

The *formula* and any parameters used in constructing `outcome` must be
committed ahead of time.  To achieve this the on‑chain contract stores a
**hash anchor** of the entire blob the server promises to use
(seed || formula || params).  Before play both parties agree on the blob,
and the server submits its keccak256 hash to the `SeedCommit` contract.
Later, when revealing the seed and publishing the randomness, anybody
can recompute the hash and compare it to the on‑chain anchor.

This prevents the time‑travel attack you described: the server cannot
publish a different formula after the fact because the anchor is
immutable.  If the revealed blob doesn’t hash to the committed value,
validation fails and the server is caught lying.

The hash output can then be mapped to a desired range using standard
techniques such as ``(hash % range) + min``.  For games requiring
multiple independent values (e.g. a hand of cards), derive them by
re‑hashing with an index or looping with a pseudo‑random number
generator seeded from the hash.

```python
# example Python utility
import hashlib

def derive(seed: bytes, rnd: bytes, min_val: int, max_val: int, index: int = 0) -> int:
    data = seed + rnd + index.to_bytes(4, "big")
    h = hashlib.sha256(data).digest()
    val = int.from_bytes(h, "big")
    return (val % (max_val - min_val + 1)) + min_val
```

## Scalability

Because the on‑chain contract never performs the above math, it scales to
*any* game: dice, slots, MMOs, lotteries, etc.  The only blockchain
interaction is storing and later reading the commitment; all outcome
generation happens off‑chain where performance and flexibility are
unconstrained.

Servers and clients can independently compute and verify outcomes, which
is the essence of provable fairness.
